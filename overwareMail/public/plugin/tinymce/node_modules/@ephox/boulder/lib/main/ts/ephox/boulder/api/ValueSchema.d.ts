import { Result } from '@ephox/katamari';
import { arrOf, ValueProcessorAdt, Processor, ValueValidator, setOf, objOf, objOfOnly } from '../core/ValueProcessor';
export interface SchemaError<T> {
    input: T;
    errors: any[];
}
declare const arrOfObj: (objFields: ValueProcessorAdt[]) => Processor;
declare const arrOfVal: () => Processor;
declare const valueOf: (validator: ValueValidator) => Processor;
declare const asStruct: <T, U = any>(label: string, prop: Processor, obj: U) => Result<T, SchemaError<U>>;
declare const asRaw: <T, U = any>(label: string, prop: Processor, obj: U) => Result<T, SchemaError<U>>;
declare const getOrDie: (extraction: Result<any, any>) => any;
declare const asRawOrDie: (label: string, prop: Processor, obj: any) => any;
declare const asStructOrDie: (label: string, prop: Processor, obj: any) => any;
declare const formatError: (errInfo: SchemaError<any>) => string;
declare const choose: (key: string, branches: any) => Processor;
declare const thunkOf: (desc: string, schema: () => Processor) => Processor;
declare const funcOrDie: (args: any[], prop: Processor) => Processor;
declare const anyValue: (...x: any[]) => Processor;
declare const number: Processor;
declare const string: Processor;
declare const boolean: Processor;
declare const functionProcessor: Processor;
export { anyValue, arrOfObj, arrOf, arrOfVal, valueOf, setOf, objOf, objOfOnly, asStruct, asRaw, asStructOrDie, asRawOrDie, getOrDie, formatError, choose, thunkOf, funcOrDie, number, string, boolean, functionProcessor as func };
