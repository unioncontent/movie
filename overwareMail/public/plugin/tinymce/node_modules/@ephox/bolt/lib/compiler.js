(function (scope) {
var ephox = scope.ephox = scope.ephox || {};
var bolt = ephox.bolt = ephox.bolt || {};

var def = function (deps, factory) {
    return factory.apply(null, deps);
};
var compiler = bolt.compiler = bolt.compiler || {};
compiler.bootstrap = compiler.bootstrap || {};
compiler.compile = compiler.compile || {};
compiler.inspect = compiler.inspect || {};
compiler.generator = compiler.generator || {};
compiler.minibolt = compiler.minibolt || {};
compiler.mode = compiler.mode || {};
compiler.modulator = compiler.modulator || {};
compiler.tools = compiler.tools || {};
compiler.tools.error = def(
  [
  ],

  function () {
    // A bit messy, but gives us the start of a bolt-wide logging instance
    var die;
    var setOutput = function (error, exit) {
      die = function (message, success) {
        error("error: " + message + "\n");
        exit(success === true);
      };
    };

    setOutput(console.error, function (success) {
      process.exit(success ? 0 : 1);
    });

    return {
      die: die,
      setOutput: setOutput
    };
  }
);
compiler.tools.defaults = def(
  [
  ],

  function () {
    return function () {
      return {
        config_js: 'config/bolt/prod.js',
        output_dir: 'scratch/main/js',
        src_dir: 'src/main/js',
        generate_inline: false,
        generate_modules: false,
        minimise_module_names: false,
        register_modules: false,
        main: undefined,
        entry_points: [],
        entry_groups: {},
        verbosity: 0
      };
    };
  }
);
compiler.tools.io = def(
  [
    require('fs'),
    compiler.tools.error
  ],

  function (fs, error) {
    var lazyread = function (file) {
      var data;
      return function () {
        if (data === undefined)
          data = read(file);
        return data;
      };
    };

    var read = function (file) {
      if (!exists(file))
        error.die('File read error: expected file to exist, ' + file);
      return fs.readFileSync(file, 'UTF-8');
    };

    var readall = function (files) {
      return files.map(read);
    };

    var write = function (file, contents) {
      return fs.writeFileSync(file, contents);
    };

    var exists = function (file) {
      return fs.existsSync(file);
    };

    var rm = function (file) {
      fs.unlinkSync(file);
    };

    var saferm = function (file) {
      if (exists(file))
        rm(file);
    };

    return {
      lazyread: lazyread,
      read: read,
      readall: readall,
      write: write,
      exists: exists,
      rm: rm,
      saferm: saferm
    };
  }
);
compiler.tools.files = def(
  [
    compiler.tools.io
  ],

  function (io) {
    var filenames = function (relative, names) {
      return names.map(function (x) {
        return relative + '/' + x;
      });
    };

    var files = function (relative, names) {
      return io.readall(filenames(relative, names));
    };

    return {
      filenames: filenames,
      files: files
    };
  }
);
compiler.minibolt.minibolt = def(
  [
    ephox.bolt.kernel.api.config,
    ephox.bolt.module.config.builtins,
    compiler.tools.error
  ],

  function (config, builtins, error) {
    var require = function (configuration, ids, onsuccess) {
      var bolt = config.configure(configuration, builtins.commonjs, error.die);
      global.define = bolt.define;
      bolt.require(ids, function (/* modules */) {
        delete global.define;
        onsuccess(arguments);
      });
    };

    return {
      require: require
    };
  }
);
compiler.inspect.metalator = def(
  [
    ephox.bolt.kernel.fp.array,
    compiler.tools.io,
    compiler.tools.error
  ],

  function (ar, io, error) {
    var guard = function (file) {
      if (!hasMetadata(file))
        error.die('no meta-data found for file, "' + file + '", can only link compile output');
    };

    var render = function (ids) {
      return '/*jsc\n' + JSON.stringify(ids) + '\njsc*/\n';
    };

    var cachedHasMetadata = {};

    var hasMetadata = function (file) {
      if (!cachedHasMetadata.hasOwnProperty(file)) {
        var content = io.read(file);
        cachedHasMetadata[file] = content.indexOf('/*jsc') === 0;
      }

      return cachedHasMetadata[file];
    };

    var inspect = function (file) {
      guard(file);
      var content = io.read(file);
      var end = content.indexOf('jsc*/');
      if (end === -1)
        error.die('Linking error: missing or invalid metadata for file, ' + file);
      var comment = content.substring(0, end);
      var json = comment.replace(/\/\*jsc/, '').replace(/jsc\*\//, '');
      return JSON.parse(json);
    };

    var boltmodules = function (file) {
      guard(file);
      return inspect(file);
    };

    var spec = function (file) {
      if (!hasMetadata(file))
        error.die('no meta-data found for file, "' + file + '", can only link compile output');
      var defines = inspect(file);
      return { file: file, defines: defines };
    };

    return {
      render: render,
      hasMetadata: hasMetadata,
      inspect: inspect,
      boltmodules: boltmodules,
      spec: spec
    };
  }
);
compiler.inspect.identifier = def(
  [
    compiler.tools.io,
    compiler.tools.error
  ],

  function (io, error) {
    var indentify = function (file) {
      var content = io.read(file);
      var ids = [];
      // eval scope
      var define = function (id) {
        ids.push(id);
      };
      try {
        eval(content);
      } catch (e) {
        error.die('Could not evaluate file: ' + file + ', error: ' + e);
      }
      return ids;
    };

    return {
      identify: indentify
    };
  }
);
compiler.generator.bootstrap = def(
  [
    compiler.tools.files,
    compiler.tools.io
  ],

  function (files, io) {
    var generate = function (target, bonus) {
      io.saferm(target);
      var corefiles = files.files(__dirname, ['kernel.js', 'loader.js', 'module.js', 'globaldef.js']);
      var contents =  corefiles.join('\n') + bonus;
      io.write(target, contents);
    };

    return {
      generate: generate
    };
  }
);
compiler.generator.inline = def(
  [
    compiler.tools.files,
    compiler.tools.io
  ],

  function (files, io) {
    var generate = function (target, compiled) {
      io.saferm(target);
      var fs = files.files(__dirname, ['inline.js', 'inline.js.pre', 'inline.js.post']);
      var inline = fs[0];
      var pre = fs[1];
      var post = fs[2];

      var contents = [ pre, inline, compiled, post ].join('\n');
      io.write(target, contents);
    };

    return {
      generate: generate
    };
  }
);
compiler.modulator.bolt = def(
  [
    compiler.inspect.metalator,
    compiler.tools.io,
    compiler.tools.error
  ],

  // FIX cleanup after compiled/bolt unify
  function (metalator, io, error) {
    var create = function (pather, namespace, path, idTransformer) {

      var can = function (id) {
        return id.indexOf(namespace) === 0;
      };

      var get = function (id) {
        var file = pather(path) + "/" + idTransformer(id) + '.js';
        var content = io.lazyread(file);

        var render = function () {
          return content();
        };

        var loadcompiled = function (define) {
          var ids = metalator.inspect(file);
          ids.forEach(function (id) {
            define(id, []);
          });
        };

        var loadmodule = function (define /* eval scope */) {
          try {
            eval(content());
          } catch (e) {
            error.die('Could not evaluate file: ' + file + ', error: ' + e);
          }
        };

        var load = function (define) {
          var loader = metalator.hasMetadata(file) ? loadcompiled : loadmodule;
          loader(define);
        };

        return {
          url: file,
          serial: false,
          render: render,
          load: load
        };
      };

      return {
        can: can,
        get: get
      };
    };

    return {
      create: create
    };
  }
);
compiler.modulator.globalator = def(
  [
  ],

  function () {
    var create = function () {
      var can = function (id) {
        return id.indexOf('global!') === 0;
      };

      var renderNormal = function (id, globalid) {
        return function () {
          return 'defineGlobal("' + id + '", ' + globalid + ');';
        };
      };

      var renderConsole = function () {
        return 'define("global!console", [], function () { if (typeof console === "undefined") console = { log: function () {} }; return console; });';
      };

      var get = function (id) {
        var globalid = id.substring('global!'.length);

        var render = globalid === 'console' ? renderConsole : renderNormal(id, globalid);

        var load = function (define) {
          define(id, []);
        };

        return {
          url: globalid,
          serial: false,
          render: render,
          load: load
        };
      };

      return {
        can: can,
        get: get
      };
    };

    return {
      create: create
    };
  }
);
compiler.compile.renderer = def(
  [
    ephox.bolt.kernel.fp.array
  ],

  function (ar) {
    var stripempty = function (ss) {
      return ar.filter(ss, function (s) {
         return s !== '';
      });
    };

    var join = function (ss) {
      return stripempty(ss).join('\n');
    };

    var render = function (ids, modules, renders) {
      var found = {};  // url ->  boolean
      var sorted = [];

      // traverse the dependency tree, producing a list of modules in dependency order.
      var findDependencies = function (id) {
        var spec = renders[id];
        if (spec === undefined) throw 'undefined render for ' + id + ', deps ' + modules[id];
        else if (found[spec.url] === true) return; // already found, no need to search any further

        // recursively search this module's dependencies
        var deps = modules[id];
        ar.each(deps, findDependencies);

        // mark this module as found, and add it to the list
        found[spec.url] = true;
        sorted.push(id);
      };

      ar.each(ids, findDependencies);

      var rendered = sorted.map(function (id) {
        return renders[id].render();
      });

      return join(rendered);
    };

    return {
      render: render
    };
  }
);
compiler.compile.sources = def(
  [
    ephox.bolt.kernel.fp.array,
    compiler.modulator.globalator,
    compiler.modulator.bolt,
    compiler.minibolt.minibolt,
    compiler.tools.error
  ],

  function (ar, globalator, bolt, minibolt, error) {
    var build = function (configuration, callback) {
      var modulatorids = ar.map(configuration.types, function (spec) {
        return spec.compiler
      });

      minibolt.require(configuration, modulatorids, function (modules) {
        var types = {};
        ar.each(configuration.types, function (spec, i) {
          types[spec.type] = modules[i];
        });
        types.bolt = bolt;
        // TODO: 'amd' is maintained for backwards compatibility, will be
        // removed at some point.
        types.amd = bolt;

        var sources = [ globalator.create() ];

        ar.each(configuration.sources, function (spec) {
          if (types[spec.type] === undefined)
            error.die('Unknown modulator type [' + spec.type + ']');
          var modulator = types[spec.type];
          var source = modulator.create.apply(null, spec.args);
          sources.push(source);
        });

        var can = function (id) {
          for (var i = 0; i < sources.length; ++i)
            if (sources[i].can(id))
              return true;
          return false;
        };

        var load = function (id) {
          for (var i = 0; i < sources.length; ++i)
            if (sources[i].can(id))
              return sources[i].get(id);
          throw 'No sources found to load module [' + id + ']';
        };

        callback({
          can: can,
          load: load
        });
      });
    };

    return {
      build: build
    };
  }
);
// FIX reconsider name, but compiler.compile.compiler.compile() method calls would rock.
compiler.compile.compiler = def(
  [
    compiler.inspect.metalator,
    compiler.tools.io,
    compiler.tools.error,
    compiler.compile.renderer,
    ephox.bolt.kernel.module.analyser,
    ephox.bolt.kernel.fp.functions,
    ephox.bolt.kernel.fp.object
  ],

  function (metalator, io, error, renderer, analyser, fn, obj) {
    return function () {
      var modules = {}; // id -> [id]
      var renders = {}; // id -> spec

      var analyse = function (ids) {
        var results = analyser.analyse(ids, modules);
        if (results.cycle)
          error.die('cycle detected whilst compiling modules: ' + results.cycle.join(' ~> '));
        return results;
      };

      var load = function (sources, id) {
        var spec = sources.load(id);
        renders[id] = spec;
        spec.load(function (id, dependencies) {
          modules[id] = dependencies;
        });
      };

      var checkedload = function (sources, id) {
        if (!sources.can(id))
          error.die('Configuration error: no source found to load module: ' + id);

        load(sources, id);

        if (modules[id] === undefined)
          error.die('Configuration error: module [' + id + '] was not loaded from expected source');
      };

      var compile = function (sources, ids) {
        var loader = fn.curry(checkedload, sources);
        var results = analyse(ids);
        while (results.load.length > 0) {
          results.load.forEach(loader);
          results = analyse(ids);
        }
        var all = obj.keys(modules);
        var header = metalator.render(all); // FIX consider separating all ids vs specified ids.
        return header + renderer.render(ids, modules, renders);
      };

      return {
        compile: compile
      };
    };
  }
);
compiler.mode.compile = def(
  [
    compiler.tools.io,
    compiler.inspect.identifier,
    compiler.compile.compiler,
    compiler.compile.sources,
    ephox.bolt.module.reader.node,
    ephox.bolt.kernel.fp.array
  ],

  function (io, identifier, compiler, sources, reader, ar) {
    var compile = function (source, files, target) {
      var modules = ar.flatmap(files, identifier.identify);
      var result = compiler().compile(source, modules);
      io.write(target, result);
    };

    var run = function (config, files, target, done) {
      reader.read(process.cwd() + '/.', config, function (configuration) {
        sources.build(configuration, function (source) {
          compile(source, files, target);
          done && done();
        });
      });
    };

    return {
      run: run
    };
  }
);
compiler.mode.identify = def(
  [
    compiler.tools.error,
    compiler.inspect.identifier
  ],

  function (error, identifier) {
    var run = function (file) {
      var ids = identifier.identify(file);
      if (ids.length > 1)
        error.die('File: ' + file + ', contained more than one module: [' + ids.join(', ') + ']');
      return ids[0];
    };

    return {
      run: run
    };
  }
);
compiler.mode.inline = def(
  [
    compiler.tools.files,
    compiler.tools.io,
    compiler.tools.error,
    compiler.inspect.metalator,
    compiler.generator.inline,
    ephox.bolt.kernel.fp.array
  ],

  function (filer, io, error, metalator, inline, ar) {

    var replaceAll = function (string, target, value) {
      var search = '["\']' + target + '["\']'; // FIX: Be more precise here. Either '<module-name>' or "<module-name>".
      return string.replace(new RegExp(search, 'g'), value);
    };

    var readall = function (files) {
      var read = io.readall(files);
      return read.join('\n');
    };

    var run = function (config, files, target, registermodules, main, minimiseModuleNames, verbosity) {
      // moved register inside this function so we have access to the list of IDs for obfuscation
      var ids = ar.flatmap(files, metalator.boltmodules);
      var register = function (ids) {
        return ar.map(ids, function (id) {
          // unique name defined in inline/src/inline.js
          return 'register_3795(\'' + id + '\');';
        }).join('\n');
      };

      var result = readall(files);
      if (registermodules || main === undefined) {
        result += '\n' + register(ids);
      } else {
        result += '\ndem(\'' + main + '\')();';
      }

      var doMinimiseModuleNames = function () {
        var mkNextId = function() {
          var base = 36;
          var moduleIndex = 0;
          var nextId = function() {
            var currentIndex = moduleIndex;
            ++moduleIndex;
            return JSON.stringify(currentIndex.toString(base));
          };
          return nextId;
        };
        var nextId = mkNextId();
        ar.each(ids, function (id) {
          var mappedTo = nextId();
          if (verbosity > 0) console.log("Mapping module %s ⇒ %s", JSON.stringify(id), mappedTo);
          result = replaceAll(result, id, mappedTo);
        });
      };

      if (minimiseModuleNames) {
        inline.generate(target + '.raw.js', result);
        doMinimiseModuleNames();
      }

      inline.generate(target + '.js', result);
    };

    return {
      run: run
    };
  }
);
compiler.mode.link = def(
  [
    compiler.tools.error,
    compiler.tools.io,
    compiler.generator.bootstrap,
    compiler.inspect.metalator,
    ephox.bolt.kernel.fp.array,
    require('path')
  ],

  function (error, io, generator, metalator, ar, path) {
    var source = function (spec) {
      var name = path.basename(spec.file, '.js');
      return ar.map(spec.defines, function (define) {
        return 'source("bolt", "' + define + '", ".", mapper.constant("' + name + '"))';
      });
    };

    var run = function (config, files, target) {
      var specs = files.map(metalator.spec);
      var sources = ar.flatmap(specs, source);

      var install =
        '(function () {\n' +
        '  var install = ephox.bolt.module.bootstrap.install;\n' +
        '  var builtins = ephox.bolt.module.config.builtins.browser;\n' +
        '  var transport = ephox.bolt.loader.transporter.xhr.request;\n' +
        '  var script = ephox.bolt.loader.api.scripttag.load;\n' +
        '  var direct = ephox.bolt.module.reader.direct;\n' +
        '  var mapper = ephox.bolt.module.config.mapper;\n' +
        '  var locator = ephox.bolt.module.util.locator;\n' +
        '  var source = ephox.bolt.module.config.specs.source(locator.locate());\n' +
        '  var reader = direct.create({\n' +
        '    sources: [\n' +
        '      ' + sources.join(',\n      ') + '\n' +
        '    ]\n' +
        '  });\n' +
        '  install.install(reader, builtins, transport, script);\n' +
        '})();';

      generator.generate(target, install);
    };

    return {
      run: run
    };
  }
);
compiler.mode.dev = def(
  [
    compiler.generator.bootstrap
  ],

  function (generator) {
    var run = function (config, bootstrap) {
      var path = require('path');
      var relative = path.relative(path.dirname(bootstrap), config);

      var hookup =
        '(function (global) {\n' +
        '  var obj = ephox.bolt.kernel.fp.object;\n' +
        '  var api = ephox.bolt.module.api;\n' +
        '  var builtins = ephox.bolt.module.config.builtins.browser;\n' +
        '  var install = ephox.bolt.module.bootstrap.install;\n' +
        '  var reader = ephox.bolt.module.bootstrap.configloader.create("' + relative + '");\n' +
        '  var transport = ephox.bolt.loader.transporter.xhr.request;\n' +
        '  var script = ephox.bolt.loader.api.scripttag.load;\n' +
        '  install.install(reader, builtins, transport, script);\n' +
        '  obj.merge(global, api);\n' +
        '})(Function("return this;")());';
      generator.generate(bootstrap, hookup);
    };

    return {
      run: run
    };
  }
);
})(Function('return this')());
