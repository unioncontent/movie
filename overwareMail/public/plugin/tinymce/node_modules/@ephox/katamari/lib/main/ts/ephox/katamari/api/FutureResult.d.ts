import { Future } from './Future';
import { Result } from './Result';
export interface FutureResult<A, E> extends Future<Result<A, E>> {
    bindFuture: <B>(f: (value: A) => Future<Result<B, E>>) => FutureResult<B, E>;
    bindResult: <B>(f: (value: A) => Result<B, E>) => FutureResult<B, E>;
    mapResult: <B>(f: (value: A) => B) => FutureResult<B, E>;
    foldResult: <X>(whenError: (error: E) => X, whenValue: (value: A) => X) => Future<X>;
    withTimeout: <E2>(timeout: number, errorThunk: () => E2) => FutureResult<A, E | E2>;
}
export declare const FutureResult: {
    nu: <A = any, E = any>(worker: (completer: (result: Result<A, E>) => void) => void) => FutureResult<A, E>;
    wrap: <A = any, E = any>(delegate: Future<Result<A, E>>) => FutureResult<A, E>;
    pure: <A, E = any>(value: A) => FutureResult<A, any>;
    value: <A, E = any>(value: A) => FutureResult<A, any>;
    error: <A = any, E = any>(error: E) => FutureResult<any, E>;
    fromResult: <A, E>(result: Result<A, E>) => FutureResult<A, E>;
    fromFuture: <A, E = any>(future: Future<A>) => FutureResult<A, any>;
    fromPromise: <T, E = any>(promise: Promise<T>) => FutureResult<T, E>;
};
