var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import { Future } from './Future';
import { Result } from './Result';
var wrap = function (delegate) {
    var bindFuture = function (f) {
        return wrap(delegate.bind(function (resA) { return resA.fold(function () { return delegate; }, function (a) { return f(a); }); }));
    };
    var bindResult = function (f) {
        return wrap(delegate.map(function (resA) { return resA.bind(f); }));
    };
    var mapResult = function (f) {
        return wrap(delegate.map(function (resA) { return resA.map(f); }));
    };
    var foldResult = function (whenError, whenValue) {
        return delegate.map(function (res) { return res.fold(whenError, whenValue); });
    };
    var withTimeout = function (timeout, errorThunk) {
        return wrap(Future.nu(function (callback) {
            var timedOut = false;
            var timer = window.setTimeout(function () {
                timedOut = true;
                callback(Result.error(errorThunk()));
            }, timeout);
            delegate.get(function (result) {
                if (!timedOut) {
                    window.clearTimeout(timer);
                    callback(result);
                }
            });
        }));
    };
    return __assign({}, delegate, { bindFuture: bindFuture,
        bindResult: bindResult,
        mapResult: mapResult,
        foldResult: foldResult,
        withTimeout: withTimeout });
};
var nu = function (worker) {
    return wrap(Future.nu(worker));
};
var value = function (value) {
    return wrap(Future.pure(Result.value(value)));
};
var error = function (error) {
    return wrap(Future.pure(Result.error(error)));
};
var fromResult = function (result) {
    return wrap(Future.pure(result));
};
var fromFuture = function (future) {
    return wrap(future.map(Result.value));
};
var fromPromise = function (promise) {
    return nu(function (completer) {
        promise.then(function (value) {
            completer(Result.value(value));
        }, function (error) {
            completer(Result.error(error));
        });
    });
};
export var FutureResult = {
    nu: nu,
    wrap: wrap,
    pure: value,
    value: value,
    error: error,
    fromResult: fromResult,
    fromFuture: fromFuture,
    fromPromise: fromPromise
};
//# sourceMappingURL=FutureResult.js.map