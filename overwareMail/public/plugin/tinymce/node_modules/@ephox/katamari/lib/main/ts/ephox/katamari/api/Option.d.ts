export interface Option<T> {
    fold: <T2>(whenNone: () => T2, whenSome: (v: T) => T2) => T2;
    is: (value: T) => boolean;
    isSome: () => boolean;
    isNone: () => boolean;
    getOr: (value: T) => T;
    getOrThunk: (makeValue: () => T) => T;
    getOrDie: (msg?: string) => T;
    or: (opt: Option<T>) => Option<T>;
    orThunk: (makeOption: () => Option<T>) => Option<T>;
    map: <T2>(mapper: (x: T) => T2) => Option<T2>;
    ap: <T2>(optfab: Option<(a: T) => T2>) => Option<T2>;
    each: (worker: (x: T) => void) => void;
    bind: <T2>(f: (x: T) => Option<T2>) => Option<T2>;
    /** convert an Option<Option<A>> to Option<A> */
    flatten: () => Option<any>;
    exists: (f: (x: T) => boolean) => boolean;
    forall: (f: (x: T) => boolean) => boolean;
    filter: (f: (x: T) => boolean) => Option<T>;
    equals: (opt: Option<T>) => boolean;
    equals_: <T2>(opt: Option<T2>, equality: (a: T, b: T2) => boolean) => boolean;
    toArray: () => T[];
    toString: () => string;
}
export declare const Option: {
    some: <T>(a: T) => Option<T>;
    none: <T = any>() => Option<T>;
    from: <T>(value: T) => Option<T>;
};
