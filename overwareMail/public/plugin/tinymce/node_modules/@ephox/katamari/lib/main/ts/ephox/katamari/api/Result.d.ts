import { Option } from './Option';
export interface Result<T, E> {
    is: (value: T) => boolean;
    or: (result: Result<T, E>) => Result<T, E>;
    orThunk: (makeResult: () => Result<T, E>) => Result<T, E>;
    map: <U>(mapper: (value: T) => U) => Result<U, E>;
    each: (worker: (value: T) => void) => void;
    bind: <U>(binder: (value: T) => Result<U, E>) => Result<U, E>;
    fold: <U>(whenError: (err: E) => U, mapper: (value: T) => U) => U;
    exists: (predicate: (value: T) => boolean) => boolean;
    forall: (predicate: (value: T) => boolean) => boolean;
    toOption: () => Option<T>;
    isValue: () => boolean;
    isError: () => boolean;
    getOr: (defaultValue: T) => T;
    getOrThunk: (maker: () => T) => T;
    getOrDie: () => T;
}
export declare const Result: {
    value: <T, E = any>(o: T) => Result<T, E>;
    error: <T = any, E = any>(message: E) => Result<T, E>;
};
