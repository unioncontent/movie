import { Option } from './Option';
declare const _default: {
    map: <T = any, U = any>(xs: ReadonlyArray<T>, f: (x: T, i: number, xs: ReadonlyArray<T>) => U) => U[];
    each: <T = any>(xs: ReadonlyArray<T>, f: (x: T, i: number, xs: ReadonlyArray<T>) => void) => void;
    eachr: <T = any>(xs: ReadonlyArray<T>, f: (x: T, i: number, xs: ReadonlyArray<T>) => void) => void;
    partition: <T = any>(xs: ReadonlyArray<T>, pred: (x: T, i: number, xs: ReadonlyArray<T>) => boolean) => {
        pass: T[];
        fail: T[];
    };
    filter: <T = any>(xs: ReadonlyArray<T>, pred: (x: T, i: number, xs: ReadonlyArray<T>) => boolean) => T[];
    groupBy: <T = any>(xs: ReadonlyArray<T>, f: (a: T) => any) => T[][];
    indexOf: <T = any>(xs: ReadonlyArray<T>, x: T) => Option<number>;
    foldr: <T = any, U = any>(xs: ReadonlyArray<T>, f: (acc: U, x: T) => U, acc: U) => U;
    foldl: <T = any, U = any>(xs: ReadonlyArray<T>, f: (acc: U, x: T) => U, acc: U) => U;
    find: <T = any>(xs: ReadonlyArray<T>, pred: (x: T, i: number, xs: ReadonlyArray<T>) => boolean) => Option<T>;
    findIndex: <T = any>(xs: ReadonlyArray<T>, pred: (x: T, i: number, xs: ReadonlyArray<T>) => boolean) => Option<number>;
    flatten: <T = any>(xs: ReadonlyArray<ReadonlyArray<T> | T[]>) => T[];
    bind: <T = any, U = any>(xs: ReadonlyArray<T>, f: (x: T, i: number, xs: ReadonlyArray<T>) => U[]) => U[];
    forall: <T = any>(xs: ReadonlyArray<T>, pred: (x: T, i: number, xs: ReadonlyArray<T>) => boolean) => boolean;
    exists: <T = any>(xs: ReadonlyArray<T>, pred: (x: T, i: number, xs: ReadonlyArray<T>) => boolean) => boolean;
    contains: <T = any>(xs: ReadonlyArray<T>, x: T) => boolean;
    equal: <T = any>(a1: ReadonlyArray<T>, a2: T[]) => boolean;
    reverse: <T = any>(xs: ReadonlyArray<T>) => T[];
    chunk: <T = any>(array: ReadonlyArray<T>, size: number) => T[][];
    difference: <T = any>(a1: ReadonlyArray<T>, a2: ReadonlyArray<T>) => T[];
    mapToObject: <T = any, U = any>(xs: ReadonlyArray<T>, f: (x: T, i: number) => U) => Record<string, U>;
    pure: <T = any>(x: T) => T[];
    sort: <T = any>(xs: ReadonlyArray<T>, comparator?: (a: T, b: T) => number) => T[];
    range: <T = any>(num: number, f: (a: number) => T) => T[];
    head: <T = any>(xs: ReadonlyArray<T>) => Option<T>;
    last: <T = any>(xs: ReadonlyArray<T>) => Option<T>;
    from: <T = any>(x: ArrayLike<T>) => T[];
};
export default _default;
